// ============================================
// PAYNOVA BACKEND - QUICK START PACKAGE
// ============================================

// Package.json for backend
const packageJson = {
  "name": "paynova-backend",
  "version": "1.0.0",
  "description": "PayNova Backend API",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "migrate": "node src/database/migrate.js",
    "seed": "node src/database/seed.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.3",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.35.2",
    "redis": "^4.6.12",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "speakeasy": "^2.0.0",
    "qrcode": "^1.5.3",
    "dotenv": "^16.3.1",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "joi": "^17.11.0",
    "multer": "^1.4.5-lts.1",
    "aws-sdk": "^2.1505.0",
    "sharp": "^0.33.1",
    "axios": "^1.6.3",
    "socket.io": "^4.6.1",
    "nodemailer": "^6.9.7",
    "twilio": "^4.20.0",
    "winston": "^3.11.0",
    "pdfkit": "^0.14.0",
    "tesseract.js": "^5.0.4"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0",
    "supertest": "^6.3.3"
  }
};

// ============================================
// SERVER.JS - Main entry point
// ============================================
const server_js = `
require('dotenv').config();
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const { sequelize } = require('./config/database');
const redis = require('./config/redis');
const socketHandler = require('./websocket/socketHandler');
const errorHandler = require('./middleware/errorHandler');
const logger = require('./utils/logger');

const app = express();
const PORT = process.env.PORT || 5000;

// Security Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// API Routes
app.use('/api/v1/auth', require('./routes/auth'));
app.use('/api/v1/users', require('./routes/users'));
app.use('/api/v1/wallets', require('./routes/wallets'));
app.use('/api/v1/transactions', require('./routes/transactions'));
app.use('/api/v1/exchange', require('./routes/exchange'));
app.use('/api/v1/transfer', require('./routes/transfer'));
app.use('/api/v1/markets', require('./routes/markets'));
app.use('/api/v1/alerts', require('./routes/alerts'));
app.use('/api/v1/watchlist', require('./routes/watchlist'));
app.use('/api/v1/admin', require('./routes/admin'));

// Error handling
app.use(errorHandler);

// Start server
const httpServer = app.listen(PORT, async () => {
  try {
    // Test database connection
    await sequelize.authenticate();
    logger.info('Database connected successfully');
    
    // Test Redis connection
    await redis.ping();
    logger.info('Redis connected successfully');
    
    logger.info(\`PayNova Backend running on port \${PORT}\`);
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
});

// Initialize WebSocket
socketHandler.init(httpServer);

// Start background workers
require('./workers/marketDataWorker').start();
require('./workers/alertWorker').start();
require('./workers/settlementWorker').start();

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM signal received: closing HTTP server');
  httpServer.close(async () => {
    await sequelize.close();
    await redis.quit();
    logger.info('Server closed');
    process.exit(0);
  });
});

module.exports = app;
`;

// ============================================
// DATABASE CONFIG
// ============================================
const database_config = `
const { Sequelize } = require('sequelize');
const logger = require('../utils/logger');

const sequelize = new Sequelize(process.env.DATABASE_URL, {
  dialect: 'postgres',
  logging: (msg) => logger.debug(msg),
  pool: {
    max: 10,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});

// Models
const User = require('../models/User')(sequelize);
const Wallet = require('../models/Wallet')(sequelize);
const Transaction = require('../models/Transaction')(sequelize);
const SettlementProof = require('../models/SettlementProof')(sequelize);
const PriceAlert = require('../models/PriceAlert')(sequelize);
const Watchlist = require('../models/Watchlist')(sequelize);

// Associations
User.hasMany(Wallet, { foreignKey: 'user_id' });
Wallet.belongsTo(User, { foreignKey: 'user_id' });

User.hasMany(Transaction, { foreignKey: 'user_id' });
Transaction.belongsTo(User, { foreignKey: 'user_id' });

Transaction.hasMany(SettlementProof, { foreignKey: 'transaction_id' });
SettlementProof.belongsTo(Transaction, { foreignKey: 'transaction_id' });

User.hasMany(PriceAlert, { foreignKey: 'user_id' });
PriceAlert.belongsTo(User, { foreignKey: 'user_id' });

User.hasMany(Watchlist, { foreignKey: 'user_id' });
Watchlist.belongsTo(User, { foreignKey: 'user_id' });

module.exports = {
  sequelize,
  User,
  Wallet,
  Transaction,
  SettlementProof,
  PriceAlert,
  Watchlist
};
`;

// ============================================
// AUTH CONTROLLER
// ============================================
const authController = `
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');
const { User } = require('../config/database');
const emailService = require('../services/emailService');
const logger = require('../utils/logger');

class AuthController {
  async signup(req, res) {
    try {
      const { email, password, full_name } = req.body;
      
      // Check if user exists
      const existingUser = await User.findOne({ where: { email } });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'Email already registered'
        });
      }
      
      // Hash password
      const password_hash = await bcrypt.hash(password, 12);
      
      // Create user
      const user = await User.create({
        email,
        password_hash,
        full_name,
        email_verified: false
      });
      
      // Generate verification token
      const verificationToken = jwt.sign(
        { userId: user.id, type: 'email_verification' },
        process.env.JWT_SECRET,
        { expiresIn: '24h' }
      );
      
      // Send verification email
      await emailService.sendVerificationEmail(email, verificationToken);
      
      // Create default wallets
      await this.createDefaultWallets(user.id);
      
      res.status(201).json({
        success: true,
        message: 'Registration successful. Please verify your email.',
        data: {
          userId: user.id,
          email: user.email
        }
      });
      
    } catch (error) {
      logger.error('Signup error:', error);
      res.status(500).json({
        success: false,
        message: 'Registration failed'
      });
    }
  }
  
  async signin(req, res) {
    try {
      const { email, password } = req.body;
      
      // Find user
      const user = await User.findOne({ where: { email } });
      if (!user) {
        return res.status(401).json({
          success: false,
          message: 'Invalid credentials'
        });
      }
      
      // Verify password
      const isValid = await bcrypt.compare(password, user.password_hash);
      if (!isValid) {
        return res.status(401).json({
          success: false,
          message: 'Invalid credentials'
        });
      }
      
      // Check if 2FA is enabled
      if (user.is_2fa_enabled) {
        // Generate temporary token for 2FA verification
        const tempToken = jwt.sign(
          { userId: user.id, type: '2fa_pending' },
          process.env.JWT_SECRET,
          { expiresIn: '5m' }
        );
        
        return res.json({
          success: true,
          requires2FA: true,
          tempToken
        });
      }
      
      // Generate tokens
      const token = this.generateToken(user.id);
      const refreshToken = this.generateRefreshToken(user.id);
      
      // Update last login
      await user.update({ last_login: new Date() });
      
      res.json({
        success: true,
        data: {
          token,
          refreshToken,
          user: {
            id: user.id,
            email: user.email,
            full_name: user.full_name
          }
        }
      });
      
    } catch (error) {
      logger.error('Signin error:', error);
      res.status(500).json({
        success: false,
        message: 'Login failed'
      });
    }
  }
  
  async setup2FA(req, res) {
    try {
      const userId = req.user.id;
      
      // Generate secret
      const secret = speakeasy.generateSecret({
        name: \`PayNova (\${req.user.email})\`,
        issuer: 'PayNova'
      });
      
      // Generate QR code
      const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);
      
      // Store secret temporarily (will be confirmed after verification)
      await req.user.update({ totp_secret: secret.base32 });
      
      res.json({
        success: true,
        data: {
          secret: secret.base32,
          qrCode: qrCodeUrl
        }
      });
      
    } catch (error) {
      logger.error('2FA setup error:', error);
      res.status(500).json({
        success: false,
        message: '2FA setup failed'
      });
    }
  }
  
  async verify2FA(req, res) {
    try {
      const { token, tempToken } = req.body;
      
      // Verify temp token
      const decoded = jwt.verify(tempToken, process.env.JWT_SECRET);
      if (decoded.type !== '2fa_pending') {
        return res.status(401).json({
          success: false,
          message: 'Invalid token'
        });
      }
      
      const user = await User.findByPk(decoded.userId);
      
      // Verify TOTP
      const verified = speakeasy.totp.verify({
        secret: user.totp_secret,
        encoding: 'base32',
        token,
        window: 2
      });
      
      if (!verified) {
        return res.status(401).json({
          success: false,
          message: 'Invalid 2FA code'
        });
      }
      
      // Enable 2FA if not already enabled
      if (!user.is_2fa_enabled) {
        await user.update({ is_2fa_enabled: true });
      }
      
      // Generate actual tokens
      const authToken = this.generateToken(user.id);
      const refreshToken = this.generateRefreshToken(user.id);
      
      res.json({
        success: true,
        data: {
          token: authToken,
          refreshToken,
          user: {
            id: user.id,
            email: user.email,
            full_name: user.full_name
          }
        }
      });
      
    } catch (error) {
      logger.error('2FA verification error:', error);
      res.status(500).json({
        success: false,
        message: '2FA verification failed'
      });
    }
  }
  
  generateToken(userId) {
    return jwt.sign(
      { id: userId, type: 'access' },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES_IN || '24h' }
    );
  }
  
  generateRefreshToken(userId) {
    return jwt.sign(
      { id: userId, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d' }
    );
  }
  
  async createDefaultWallets(userId) {
    const { Wallet } = require('../config/database');
    const currencies = ['USD', 'EUR', 'BTC', 'ETH'];
    
    for (const currency of currencies) {
      await Wallet.create({
        user_id: userId,
        currency,
        balance: 0,
        is_crypto: ['BTC', 'ETH'].includes(currency)
      });
    }
  }
}

module.exports = new AuthController();
`;

// ============================================
// EXCHANGE CONTROLLER
// ============================================
const exchangeController = `
const { Transaction, SettlementProof, Wallet } = require('../config/database');
const exchangeRateService = require('../services/exchangeRateService');
const fileUploadService = require('../services/fileUploadService');
const { v4: uuidv4 } = require('uuid');
const logger = require('../utils/logger');

class ExchangeController {
  async getRates(req, res) {
    try {
      const { base = 'USD' } = req.query;
      const rates = await exchangeRateService.getRates(base);
      
      res.json({
        success: true,
        data: {
          base,
          rates,
          timestamp: new Date().toISOString()
        }
      });
    } catch (error) {
      logger.error('Get rates error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch exchange rates'
      });
    }
  }
  
  async calculateExchange(req, res) {
    try {
      const { fromCurrency, toCurrency, amount } = req.body;
      const feePercentage = 0.015; // 1.5%
      
      const convertedAmount = await exchangeRateService.convertCurrency(
        amount,
        fromCurrency,
        toCurrency
      );
      
      const fee = convertedAmount * feePercentage;
      const finalAmount = convertedAmount - fee;
      const rate = convertedAmount / amount;
      
      res.json({
        success: true,
        data: {
          fromAmount: amount,
          fromCurrency,
          toAmount: finalAmount,
          toCurrency,
          rate,
          fee,
          feePercentage: feePercentage * 100
        }
      });
    } catch (error) {
      logger.error('Calculate exchange error:', error);
      res.status(500).json({
        success: false,
        message: 'Calculation failed'
      });
    }
  }
  
  async executeExchange(req, res) {
    try {
      const { fromCurrency, toCurrency, amount } = req.body;
      const userId = req.user.id;
      
      // Find user's wallets
      const fromWallet = await Wallet.findOne({
        where: { user_id: userId, currency: fromCurrency }
      });
      
      const toWallet = await Wallet.findOne({
        where: { user_id: userId, currency: toCurrency }
      });
      
      if (!fromWallet || !toWallet) {
        return res.status(400).json({
          success: false,
          message: 'Wallet not found'
        });
      }
      
      // Check balance
      if (fromWallet.balance < amount) {
        return res.status(400).json({
          success: false,
          message: 'Insufficient balance'
        });
      }
      
      // Calculate exchange
      const feePercentage = 0.015;
      const convertedAmount = await exchangeRateService.convertCurrency(
        amount,
        fromCurrency,
        toCurrency
      );
      const fee = convertedAmount * feePercentage;
      const finalAmount = convertedAmount - fee;
      const rate = convertedAmount / amount;
      
      // Create transaction
      const transaction = await Transaction.create({
        user_id: userId,
        type: 'exchange',
        from_wallet_id: fromWallet.id,
        to_wallet_id: toWallet.id,
        from_currency: fromCurrency,
        to_currency: toCurrency,
        from_amount: amount,
        to_amount: finalAmount,
        fee,
        exchange_rate: rate,
        status: 'pending',
        reference_id: \`EXC-\${uuidv4()}\`,
        counterparty: \`\${fromCurrency} to \${toCurrency}\`
      });
      
      res.json({
        success: true,
        message: 'Exchange initiated. Please submit settlement proof.',
        data: {
          transactionId: transaction.id,
          referenceId: transaction.reference_id
        }
      });
      
    } catch (error) {
      logger.error('Execute exchange error:', error);
      res.status(500).json({
        success: false,
        message: 'Exchange failed'
      });
    }
  }
  
  async submitSettlement(req, res) {
    try {
      const { transactionId, bankName, bankAccount } = req.body;
      const file = req.file;
      
      if (!file) {
        return res.status(400).json({
          success: false,
          message: 'Receipt file is required'
        });
      }
      
      // Upload to S3
      const fileUrl = await fileUploadService.uploadSettlementProof(
        file,
        transactionId
      );
      
      // Create settlement proof record
      const proof = await SettlementProof.create({
        transaction_id: transactionId,
        user_id: req.user.id,
        file_url: fileUrl,
        file_type: file.mimetype,
        file_size: file.size,
        bank_name: bankName,
        bank_account: bankAccount,
        verification_status: 'pending'
      });
      
      // Trigger automatic verification agent
      const settlementWorker = require('../workers/settlementWorker');
      settlementWorker.verifySettlement(proof.id);
      
      res.json({
        success: true,
        message: 'Settlement proof submitted successfully',
        data: {
          proofId: proof.id,
          status: 'pending'
        }
      });
      
    } catch (error) {
      logger.error('Submit settlement error:', error);
      res.status(500).json({
        success: false,
        message: 'Settlement submission failed'
      });
    }
  }
}

module.exports = new ExchangeController();
`;

console.log("PayNova Backend Quick Start Package Created!");
console.log("\\nFiles included:");
console.log("- package.json");
console.log("- server.js");
console.log("- database config");
console.log("- auth controller");
console.log("- exchange controller");
console.log("\\nTo get started:");
console.log("1. Create these files in your backend folder");
console.log("2. Run: npm install");
console.log("3. Set up .env file with your credentials");
console.log("4. Run migrations: npm run migrate");
console.log("5. Start server: npm run dev");